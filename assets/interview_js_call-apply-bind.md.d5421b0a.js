import{_ as s,o as n,c as a,Q as l}from"./chunks/framework.273ff57c.js";const b=JSON.parse('{"title":"Call与Apply与Bind","description":"","frontmatter":{"title":"Call与Apply与Bind"},"headers":[],"relativePath":"interview/js/call-apply-bind.md","filePath":"interview/js/call-apply-bind.md","lastUpdated":1699188084000}'),p={name:"interview/js/call-apply-bind.md"},o=l(`<p>这三个方法都是修改函数执行时的 this 指向，call、apply 都是立即调用函数，而 bind 是创建一个 this 指向被修改了的函数。call、apply 的唯一区别就是传参方式不同而已。</p><h3 id="call" tabindex="-1">call <a class="header-anchor" href="#call" aria-label="Permalink to &quot;call&quot;">​</a></h3><p>在调用 myCall 时，this 其实就是调用函数的那个对象，也就是目标函数。通过 this 指向始终都是最后调用该方法的那个对象的特性，给对象添加一个方法，最终调用该方法时 this 指向就是这个对象了。注意调用时不要把参数忘记了，用剩余参数来接受参数列表时获取到的是一个数组，在调用时通过展开运算符将其展开即可依次传入参数了，在调用函数后，通过 delete 删除改方法。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>在调用<code>myCall</code>时，是通过<code>fn.myCall</code>来调用的<code>myCall</code>方法，所以在<code>myCall</code>中的<code>this</code>指向<code>fn</code>。就是因为 <code>this</code> 始终指向最后调用该方法的那个对象。</p></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// call fn.call(obj,arg1,args2....)</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">myCall</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">obj</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">...</span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  obj[</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.name] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  obj[</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.name](</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">args);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">delete</span><span style="color:#E1E4E8;"> obj[</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.name];</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// call fn.call(obj,arg1,args2....)</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">myCall</span><span style="color:#24292E;">(</span><span style="color:#E36209;">obj</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">...</span><span style="color:#E36209;">args</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  obj[</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.name] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  obj[</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.name](</span><span style="color:#D73A49;">...</span><span style="color:#24292E;">args);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">delete</span><span style="color:#24292E;"> obj[</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.name];</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="apply" tabindex="-1">apply <a class="header-anchor" href="#apply" aria-label="Permalink to &quot;apply&quot;">​</a></h3><p>apply 和 call 原理差不多，只不过在调用 apply 时传入的参数方式不同而已，第一个参数都是目标函数 this 指向的目标对象，apply 的第二个参数是一个数组，数组中就是调用函数的参数了。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// apply  fn.apply(obj,[arg1,args2....])</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">myApply</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">obj</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// args是一个数组</span></span>
<span class="line"><span style="color:#E1E4E8;">  obj[</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.name] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  obj[</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.name](</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">args);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">delete</span><span style="color:#E1E4E8;"> obj[</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.name];</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// apply  fn.apply(obj,[arg1,args2....])</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">myApply</span><span style="color:#24292E;">(</span><span style="color:#E36209;">obj</span><span style="color:#24292E;">, </span><span style="color:#E36209;">args</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// args是一个数组</span></span>
<span class="line"><span style="color:#24292E;">  obj[</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.name] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  obj[</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.name](</span><span style="color:#D73A49;">...</span><span style="color:#24292E;">args);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">delete</span><span style="color:#24292E;"> obj[</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.name];</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="bind" tabindex="-1">bind <a class="header-anchor" href="#bind" aria-label="Permalink to &quot;bind&quot;">​</a></h3><p>bind 是返回一个 this 指向被修改了的函数，需要用到闭包来延长目标函数以及目标对象的生命周期。每次调用通过 bind 返回的回调函数时，都会临时去给对象添加方法并调用，最后删除这样的过程。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// bind fn.bind(obj)</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">myBind</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">obj</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 回调函数调用时可以通过闭包，获取到对象本身和函数上下文</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 这里需要通过content来保存myBind调用时的那个函数</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">content</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">...</span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 回调执行时，通过闭包获取content，也就调用mybind的那个函数</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将此函数挂载到对象自身上，并调用函数，此时的this始终为最后调用函数的对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    obj[content.name] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> content;</span></span>
<span class="line"><span style="color:#E1E4E8;">    obj[content.name](</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">args);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">delete</span><span style="color:#E1E4E8;"> obj[content.name];</span></span>
<span class="line"><span style="color:#E1E4E8;">  };</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// bind fn.bind(obj)</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">myBind</span><span style="color:#24292E;">(</span><span style="color:#E36209;">obj</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 回调函数调用时可以通过闭包，获取到对象本身和函数上下文</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 这里需要通过content来保存myBind调用时的那个函数</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">content</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">...</span><span style="color:#E36209;">args</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 回调执行时，通过闭包获取content，也就调用mybind的那个函数</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将此函数挂载到对象自身上，并调用函数，此时的this始终为最后调用函数的对象</span></span>
<span class="line"><span style="color:#24292E;">    obj[content.name] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> content;</span></span>
<span class="line"><span style="color:#24292E;">    obj[content.name](</span><span style="color:#D73A49;">...</span><span style="color:#24292E;">args);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">delete</span><span style="color:#24292E;"> obj[content.name];</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h2>`,12),e=[o];function c(t,r,y,E,i,d){return n(),a("div",null,e)}const F=s(p,[["render",c]]);export{b as __pageData,F as default};
